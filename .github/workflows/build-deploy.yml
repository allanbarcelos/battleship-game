# .github/workflows/build-deploy.yml
name: Build & Deploy

on:
  push:
    branches: [ main ]

jobs:
  discover:
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.discover.outputs.services }}
      has_root: ${{ steps.discover.outputs.has_root }}
      main_service: ${{ steps.discover.outputs.main_service }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Discover Dockerfiles
        id: discover
        run: |
          # Todos os diretórios com Dockerfile (exceto raiz por enquanto)
          SUB_SERVICES=$(find . -path ./.* -prune -o -name Dockerfile -type f | sed 's|/Dockerfile||' | sed 's|^\./||' | grep -v '^$' || true)
          
          # Verifica se existe Dockerfile na raiz
          if [ -f "Dockerfile" ]; then
            HAS_ROOT=true
            ROOT_JSON='["."]'
            echo "has_root=true" >> $GITHUB_OUTPUT
            echo "main_service=root" >> $GITHUB_OUTPUT
            echo "services=$ROOT_JSON" >> $GITHUB_OUTPUT
          else
            HAS_ROOT=false
            echo "has_root=false" >> $GITHUB_OUTPUT
            
            # Prioridade: web → api → primeiro encontrado
            if echo "$SUB_SERVICES" | grep -qx "web"; then
              MAIN="web"
            elif echo "$SUB_SERVICES" | grep -qx "api"; then
              MAIN="api"
            else
              MAIN=$(echo "$SUB_SERVICES" | head -n1)
            fi
            echo "main_service=$MAIN" >> $GITHUB_OUTPUT
            
            SERVICES_JSON=$(echo "$SUB_SERVICES" | jq -R -s -c 'split("\n") | map(select(length>0))')
            echo "services=$SERVICES_JSON" >> $GITHUB_OUTPUT
          fi

  set-env:
    runs-on: ubuntu-latest
    needs: discover
    outputs:
      repo_name: ${{ steps.env.outputs.repo_name }}
      network: ${{ steps.env.outputs.network }}
      actor: ${{ steps.env.outputs.actor }}
    steps:
      - id: env
        run: |
          echo "repo_name=${GITHUB_REPOSITORY##*/}" >> $GITHUB_OUTPUT
          echo "network=${GITHUB_REPOSITORY##*/}" >> $GITHUB_OUTPUT
          echo "actor=${GITHUB_ACTOR}" >> $GITHUB_OUTPUT

  build-push:
    needs: [discover, set-env]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: ${{ fromJson(needs.discover.outputs.services) }}
    env:
      REPO_NAME: ${{ needs.set-env.outputs.repo_name }}
      ACTOR: ${{ needs.set-env.outputs.actor }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ env.ACTOR }}
          password: ${{ secrets.GH_TOKEN }}

      - name: Build & Push Image
        run: |
          SERVICE="${{ matrix.service }}"
          REPO="${{ github.repository }}"

          # CASO 1: Dockerfile na raiz → imagem com nome limpo do repositório
          if [ "$SERVICE" = "." ]; then
            IMAGE="ghcr.io/$REPO/$REPO_NAME:latest"
            BUILD_CONTEXT="."
            echo "Root Dockerfile detected → building main image"
            echo "Image: $IMAGE"
          else
            IMAGE="ghcr.io/$REPO/$REPO_NAME-$SERVICE:latest"
            BUILD_CONTEXT="./$SERVICE"
            echo "Building service: $SERVICE"
            echo "Image: $IMAGE"
          fi

          docker build -t "$IMAGE" "$BUILD_CONTEXT"
          docker push "$IMAGE"

          # Salva para uso posterior se precisar
          echo "IMAGE_$SERVICE=$IMAGE" >> $GITHUB_ENV

  deploy:
    needs: [discover, set-env, build-push]
    runs-on: ubuntu-latest
    env:
      REPO_NAME: ${{ needs.set-env.outputs.repo_name }}
      NETWORK: ${{ needs.set-env.outputs.network }}
      HAS_ROOT: ${{ needs.discover.outputs.has_root }}
      MAIN_SERVICE: ${{ needs.discover.outputs.main_service }}
      SERVICES: ${{ needs.discover.outputs.services }}

    steps:
      - name: Create Networks
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ secrets.SSH_HST }}
          username: ${{ secrets.SSH_USR }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PRT }}
          script: |
            docker network create barcelos.dev 2>/dev/null || true
            docker network create ${{ env.NETWORK }} 2>/dev/null || true

      - name: Backup Current Images (Rollback)
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ secrets.SSH_HST }}
          username: ${{ secrets.SSH_USR }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PRT }}
          envs: REPO_NAME
          script: |
            > /tmp/rollback_${REPO_NAME}.env
            for c in $(docker ps -a --filter "name=${REPO_NAME}" --format "{{.Names}}"); do
              img=$(docker inspect --format='{{.Image}}' "$c" 2>/dev/null || echo "none")
              [ "$img" != "none" ] && echo "$c=$img" >> /tmp/rollback_${REPO_NAME}.env
            done

      - name: Deploy Containers
        uses: appleboy/ssh-action@v0.1.10
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
          SERVICES_JSON: ${{ needs.discover.outputs.services }}
          HAS_ROOT: ${{ needs.discover.outputs.has_root }}
          MAIN_SERVICE: ${{ needs.discover.outputs.main_service }}
        with:
          host: ${{ secrets.SSH_HST }}
          username: ${{ secrets.SSH_USR }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PRT }}
          script: |
            echo "$GH_TOKEN" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Para todos os containers antigos
            docker ps -a --filter "name=${REPO_NAME}" --format "{{.Names}}" | xargs -r docker rm -f

            SERVICES=($(echo "$SERVICES_JSON" | jq -r '.[]'))

            for service in "${SERVICES[@]}"; do
              if [ "$HAS_ROOT" = "true" ] && [ "$service" = "." ]; then
                IMAGE="ghcr.io/${{ github.repository }}/${REPO_NAME}:latest"
                CONTAINER="${REPO_NAME}"
              else
                IMAGE="ghcr.io/${{ github.repository }}/${REPO_NAME}-$service:latest"
                CONTAINER="${REPO_NAME}-$service"
              fi

              docker pull "$IMAGE"

              CMD="docker run -d --name $CONTAINER --restart unless-stopped --network ${NETWORK}"

              # Só o serviço principal (root ou web) fica exposto
              if ([ "$HAS_ROOT" = "true" ] && [ "$service" = "." ]) || [ "$service" = "$MAIN_SERVICE" ]; then
                CMD="$CMD --network barcelos.dev --network-alias ${REPO_NAME}"
                CMD="$CMD -p 80:80"
                CMD="$CMD -v /home/${{ secrets.SSH_USR }}/${REPO_NAME}/logs/nginx:/var/log/nginx"
              fi

              # Alias para API (caso exista)
              if [ "$service" = "api" ]; then
                CMD="$CMD --network-alias api"
              fi

              CMD="$CMD $IMAGE"
              echo "Iniciando: $CONTAINER"
              eval "$CMD"
            done

            sleep 10
            if docker ps --filter "name=${REPO_NAME}" --filter "status=running" | grep -q .; then
              sudo systemctl restart nginx
              echo "Deploy concluído com sucesso!"
            else
              echo "Falha no deploy!"
              exit 1
            fi

      - name: Rollback on Failure
        if: failure()
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ secrets.SSH_HST }}
          username: ${{ secrets.SSH_USR }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PRT }}
          envs: REPO_NAME, NETWORK
          script: |
            [ ! -f /tmp/rollback_${REPO_NAME}.env ] && exit 1
            docker ps -a --filter "name=${REPO_NAME}" --format "{{.Names}}" | xargs -r docker rm -f
            while IFS='=' read -r name image; do
              [[ -z "$name" || -z "$image" ]] && continue
              extra=""
              [[ "$name" == "${REPO_NAME}" || "$name" == "${REPO_NAME}-web" ]] && extra="--network barcelos.dev -p 80:80"
              docker run -d --name "$name" --restart unless-stopped --network ${NETWORK} $extra "$image" || true
            done < /tmp/rollback_${REPO_NAME}.env
            sudo systemctl restart nginx
            echo "Rollback executado."