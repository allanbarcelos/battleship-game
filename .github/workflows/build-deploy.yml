name: Build and Deploy Multiple

on:
  push:
    branches:
      - main

jobs:
  discover-dockerfiles:
    runs-on: ubuntu-latest
    outputs:
      dockerfiles: ${{ steps.find-dockerfiles.outputs.dockerfiles }}
      has_root_dockerfile: ${{ steps.find-dockerfiles.outputs.has_root_dockerfile }}
      main_service: ${{ steps.find-dockerfiles.outputs.main_service }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Find all Dockerfiles
        id: find-dockerfiles
        run: |
          # Find all Dockerfiles and their directories
          DOCKERFILES=$(find . -name "Dockerfile" -type f | sed 's|./||' | sed 's|/Dockerfile||' | grep -v "^\.$")
          
          ROOT_DOCKERFILE=$(find . -maxdepth 1 -name "Dockerfile" -type f)
          
          # Convert to JSON array for output - handle root Dockerfile properly
          if [ -n "$ROOT_DOCKERFILE" ]; then
            # Include root as "root" instead of "."
            DOCKERFILES_JSON=$(echo -e "root\n$DOCKERFILES" | jq -R -s -c 'split("\n") | map(select(. != "" and . != "."))')
            echo "has_root_dockerfile=true" >> $GITHUB_OUTPUT
            echo "main_service=root" >> $GITHUB_OUTPUT
          else
            DOCKERFILES_JSON=$(echo "$DOCKERFILES" | jq -R -s -c 'split("\n") | map(select(. != ""))')
            echo "has_root_dockerfile=false" >> $GITHUB_OUTPUT
            # Determine main service (app or web)
            if echo "$DOCKERFILES" | grep -q "app"; then
              echo "main_service=app" >> $GITHUB_OUTPUT
            elif echo "$DOCKERFILES" | grep -q "web"; then
              echo "main_service=web" >> $GITHUB_OUTPUT
            else
              # Use first service as main if no app/web found
              FIRST_SERVICE=$(echo "$DOCKERFILES" | head -1)
              echo "main_service=$FIRST_SERVICE" >> $GITHUB_OUTPUT
            fi
          fi
          
          echo "dockerfiles=$DOCKERFILES_JSON" >> $GITHUB_OUTPUT
          echo "Found Dockerfiles: $DOCKERFILES_JSON"
          echo "Has root Dockerfile: ${{ steps.find-dockerfiles.outputs.has_root_dockerfile }}"
          echo "Main service: ${{ steps.find-dockerfiles.outputs.main_service }}"

  set-environment:
    runs-on: ubuntu-latest
    needs: discover-dockerfiles
    outputs:
      repository_name: ${{ steps.set-env.outputs.repository_name }}
      main_network: ${{ steps.set-env.outputs.main_network }}
      repo_network: ${{ steps.set-env.outputs.repo_network }}
      gh_actor: ${{ steps.set-env.outputs.gh_actor }}
      main_service: ${{ needs.discover-dockerfiles.outputs.main_service }}
      has_root_dockerfile: ${{ needs.discover-dockerfiles.outputs.has_root_dockerfile }}
    
    steps:
      - name: Set environment variables
        id: set-env
        run: |
          REPO_NAME=${GITHUB_REPOSITORY##*/}
          echo "repository_name=$REPO_NAME" >> $GITHUB_OUTPUT
          echo "main_network=barcelos.dev" >> $GITHUB_OUTPUT
          echo "repo_network=$REPO_NAME" >> $GITHUB_OUTPUT
          echo "gh_actor=${GITHUB_ACTOR}" >> $GITHUB_OUTPUT

  build-and-push:
    runs-on: ubuntu-latest
    needs: [discover-dockerfiles, set-environment]
    strategy:
      matrix:
        service: ${{ fromJson(needs.discover-dockerfiles.outputs.dockerfiles) }}
    env:
      repository_name: ${{ needs.set-environment.outputs.repository_name }}
      gh_actor: ${{ needs.set-environment.outputs.gh_actor }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}  # Fixed: use github.actor directly
          password: ${{ secrets.GITHUB_TOKEN }}  # Fixed: use GITHUB_TOKEN

      - name: Determine image name and service name
        id: image-name
        run: |
          if [ "${{ matrix.service }}" = "root" ]; then
            IMAGE_NAME="ghcr.io/${{ github.repository }}:latest"
            SERVICE_NAME="${{ needs.set-environment.outputs.repository_name }}"
          else
            IMAGE_NAME="ghcr.io/${{ github.repository }}-${{ matrix.service }}:latest"
            SERVICE_NAME="${{ needs.set-environment.outputs.repository_name }}-${{ matrix.service }}"
          fi
          echo "image_name=$IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "service_name=$SERVICE_NAME" >> $GITHUB_OUTPUT
          echo "service_dir=${{ matrix.service }}" >> $GITHUB_OUTPUT
          echo "Building image: $IMAGE_NAME for service: $SERVICE_NAME"

      - name: Build Docker image
        run: |
          if [ "${{ matrix.service }}" = "root" ]; then
            docker build -t ${{ steps.image-name.outputs.image_name }} .
          else
            docker build -t ${{ steps.image-name.outputs.image_name }} ./${{ matrix.service }}
          fi

      - name: Push Docker image
        run: docker push ${{ steps.image-name.outputs.image_name }}

  deploy:
    runs-on: ubuntu-latest
    needs: [discover-dockerfiles, set-environment, build-and-push]
    env:
      repository_name: ${{ needs.set-environment.outputs.repository_name }}
      main_network: ${{ needs.set-environment.outputs.main_network }}
      repo_network: ${{ needs.set-environment.outputs.repo_network }}
      gh_actor: ${{ needs.set-environment.outputs.gh_actor }}
      main_service: ${{ needs.set-environment.outputs.main_service }}
      has_root_dockerfile: ${{ needs.set-environment.outputs.has_root_dockerfile }}
    
    steps:
      - name: Setup deployment environment
        id: setup
        run: |
          echo "Preparing deployment for services: ${{ join(needs.discover-dockerfiles.outputs.dockerfiles, ', ') }}"
          
          # Generate service list for deployment using jq
          DOCKERFILES='${{ needs.discover-dockerfiles.outputs.dockerfiles }}'
          REPO_NAME='${{ needs.set-environment.outputs.repository_name }}'
          HAS_ROOT='${{ needs.set-environment.outputs.has_root_dockerfile }}'
          MAIN_SERVICE='${{ needs.set-environment.outputs.main_service }}'
          
          SERVICES_JSON=$(echo "$DOCKERFILES" | jq -c --arg repo "$REPO_NAME" --arg has_root "$HAS_ROOT" --arg main_service "$MAIN_SERVICE" '
            map(
              if . == "root" then
                {
                  "name": $repo,
                  "dir": "root",
                  "is_main": true,
                  "image": ("ghcr.io/" + $repo + ":latest")
                }
              else
                {
                  "name": ($repo + "-" + .),
                  "dir": .,
                  "is_main": (. == $main_service),
                  "image": ("ghcr.io/" + $repo + "-" + . + ":latest")
                }
              end
            )
          ')
          
          echo "services_json=$SERVICES_JSON" >> $GITHUB_OUTPUT
          echo "Services to deploy: $SERVICES_JSON"

      - name: Ensure Docker networks exist
        uses: appleboy/ssh-action@v0.1.9
        with:
          host: ${{ secrets.SSH_HST }}
          username: ${{ secrets.SSH_USR }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PRT }}
          envs: main_network,repo_network
          script: |
            echo "üîç Checking Docker networks..."
            
            # Check main network
            if docker network ls | grep -q "$main_network"; then
              echo "‚úÖ Network '$main_network' already exists."
            else
              echo "üì¶ Creating network '$main_network'..."
              docker network create "$main_network"
              echo "‚úÖ Network '$main_network' created successfully."
            fi
            
            # Check repository network
            if docker network ls | grep -q "$repo_network"; then
              echo "‚úÖ Network '$repo_network' already exists."
            else
              echo "üì¶ Creating network '$repo_network'..."
              docker network create "$repo_network"
              echo "‚úÖ Network '$repo_network' created successfully."
            fi


      - name: Clean up old container structure
        uses: appleboy/ssh-action@v0.1.9
        with:
          host: ${{ secrets.SSH_HST }}
          username: ${{ secrets.SSH_USR }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PRT }}
          envs: repository_name
          script: |
            echo "üßπ Cleaning up old container structure..."
            
            # Find and remove old containers (using old naming pattern)
            OLD_CONTAINERS=$(docker ps -a --filter "name=$repository_name" --format "{{.Names}}" | grep -E "^$repository_name(-[a-zA-Z0-9_-]+)?$")
            
            if [ -n "$OLD_CONTAINERS" ]; then
              echo "Found old containers to remove:"
              echo "$OLD_CONTAINERS"
              
              for container in $OLD_CONTAINERS; do
                echo "Stopping and removing container: $container"
                docker stop "$container" 2>/dev/null || true
                docker rm "$container" 2>/dev/null || true
                echo "‚úÖ Container $container removed"
              done
            else
              echo "No old containers found with pattern: $repository_name"
            fi
            
            # Clean up old images (dangling and unused)
            echo "Cleaning up old images..."
            OLD_IMAGES=$(docker images --filter "dangling=true" -q)
            if [ -n "$OLD_IMAGES" ]; then
              echo "Removing dangling images..."
              docker rmi $OLD_IMAGES 2>/dev/null || true
            fi
            
            # Remove unused images (more aggressive cleanup)
            echo "Removing unused images..."
            docker image prune -a -f 2>/dev/null || true
            
            echo "‚úÖ Old container structure cleanup completed"


      - name: Save previous images for rollback
        uses: appleboy/ssh-action@v0.1.9
        with:
          host: ${{ secrets.SSH_HST }}
          username: ${{ secrets.SSH_USR }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PRT }}
          envs: repository_name
          script: |
            echo "Saving previous images for rollback..."
            ROLLBACK_INFO=""
            
            # Get all containers from this repository
            CONTAINERS=$(docker ps -a --filter "name=$repository_name" --format "{{.Names}}")
            
            for container in $CONTAINERS; do
              LAST_IMAGE=$(docker inspect --format='{{.Config.Image}}' "$container" 2>/dev/null || echo "")
              if [ -n "$LAST_IMAGE" ]; then
                ROLLBACK_INFO="${ROLLBACK_INFO}${container}=${LAST_IMAGE}\n"
                echo "Previous image for $container: $LAST_IMAGE"
              fi
            done
            
            echo -e "$ROLLBACK_INFO" > /tmp/rollback.env
            echo "Rollback information saved."

            - name: Deploy all containers
        id: deploy
        uses: appleboy/ssh-action@v0.1.9
        env:
          ssh_usr: ${{ secrets.SSH_USR }}
          services_json: ${{ steps.setup.outputs.services_json }}
        with:
          host: ${{ secrets.SSH_HST }}
          username: ${{ secrets.SSH_USR }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PRT }}
          envs: gh_actor,repository_name,main_network,repo_network,ssh_usr,services_json
          script: |
            set -e  # Exit on error
            set -u  # Exit on undefined variables
            
            echo "üîê Logging in to GitHub Container Registry..."
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "$gh_actor" --password-stdin

            # Parse services JSON
            SERVICES=$(echo "$services_json" | jq -c '.[]')
            
            # First, pull all images
            echo "üì¶ Pulling all images..."
            while IFS= read -r service; do
              SERVICE_NAME=$(echo "$service" | jq -r '.name')
              SERVICE_DIR=$(echo "$service" | jq -r '.dir')
              IMAGE_NAME=$(echo "$service" | jq -r '.image')
              
              echo "Pulling image: $IMAGE_NAME"
              docker pull "$IMAGE_NAME" || echo "Warning: Failed to pull $IMAGE_NAME"
            done <<< "$SERVICES"

            # Then, stop and remove old containers
            echo "üõë Stopping old containers..."
            OLD_CONTAINERS=$(docker ps -a --filter "name=$repository_name" --format "{{.Names}}" | grep -E "^$repository_name(-[a-zA-Z0-9_-]+)?$" || true)
            for container in $OLD_CONTAINERS; do
              echo "Stopping and removing: $container"
              docker stop "$container" 2>/dev/null || true
              docker rm "$container" 2>/dev/null || true
            done

            # Finally, start all new containers
            echo "üöÄ Starting all containers..."
            while IFS= read -r service; do
              SERVICE_NAME=$(echo "$service" | jq -r '.name')
              SERVICE_DIR=$(echo "$service" | jq -r '.dir')
              IS_MAIN=$(echo "$service" | jq -r '.is_main')
              IMAGE_NAME=$(echo "$service" | jq -r '.image')
              
              echo "Starting container: $SERVICE_NAME from $IMAGE_NAME"
              
              # Validate service name and image name
              if [ -z "$SERVICE_NAME" ] || [ "$SERVICE_NAME" = "null" ]; then
                echo "‚ùå ERROR: Invalid service name: $SERVICE_NAME"
                exit 1
              fi
              
              if [ -z "$IMAGE_NAME" ] || [ "$IMAGE_NAME" = "null" ]; then
                echo "‚ùå ERROR: Invalid image name: $IMAGE_NAME"
                exit 1
              fi
              
              # Base run command
              RUN_CMD="docker run -d --name \"$SERVICE_NAME\" --restart unless-stopped"
              
              # All containers get the repository network
              RUN_CMD="$RUN_CMD --network \"$repo_network\""
              
              # Main service also gets the main network
              if [ "$IS_MAIN" = "true" ]; then
                RUN_CMD="$RUN_CMD --network \"$main_network\""
                
                # Volume mapping only for main service
                RUN_CMD="$RUN_CMD -v /home/$ssh_usr/$SERVICE_NAME/logs/nginx:/var/log/nginx"
              fi
              
              RUN_CMD="$RUN_CMD \"$IMAGE_NAME\""
              
              echo "Running: $RUN_CMD"
              eval "$RUN_CMD" || echo "Warning: Container $SERVICE_NAME might have issues starting"
              
            done <<< "$SERVICES"

            echo "‚è≥ Waiting for containers to start..."
            sleep 10
            
            # Check if all containers are running
            ALL_RUNNING=true
            while IFS= read -r service; do
              SERVICE_NAME=$(echo "$service" | jq -r '.name')
              if docker inspect -f '{{.State.Running}}' "$SERVICE_NAME" 2>/dev/null | grep -q true; then
                echo "‚úÖ Container $SERVICE_NAME started successfully."
              else
                echo "‚ùå Container $SERVICE_NAME failed to start."
                ALL_RUNNING=false
                # Show logs for failed container
                docker logs "$SERVICE_NAME" 2>/dev/null || echo "No logs available for $SERVICE_NAME"
              fi
            done <<< "$SERVICES"

            if [ "$ALL_RUNNING" = true ]; then
              echo "‚úÖ All containers started successfully."
              # Restart nginx only if there's a main service
              MAIN_SERVICE_EXISTS=$(echo "$services_json" | jq 'map(select(.is_main == true)) | length')
              if [ "$MAIN_SERVICE_EXISTS" -gt 0 ]; then
                sudo systemctl restart nginx
                echo "‚úÖ Nginx restarted."
              fi
            else
              echo "‚ùå Deployment failed ‚Äî initiating rollback."
              exit 1
            fi

      - name: Rollback on failure
        if: failure()
        uses: appleboy/ssh-action@v0.1.9
        env:
          ssh_usr: ${{ secrets.SSH_USR }}
        with:
          host: ${{ secrets.SSH_HST }}
          username: ${{ secrets.SSH_USR }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PRT }}
          envs: repository_name,main_network,repo_network,ssh_usr
          script: |
            echo "üîÑ Starting rollback..."
            
            if [ ! -f /tmp/rollback.env ]; then
              echo "‚ùå No rollback file found."
              exit 1
            fi
            
            # Stop and remove current containers
            echo "üõë Stopping current containers..."
            CURRENT_CONTAINERS=$(docker ps -a --filter "name=$repository_name" --format "{{.Names}}")
            for container in $CURRENT_CONTAINERS; do
              docker stop "$container" 2>/dev/null || true
              docker rm "$container" 2>/dev/null || true
            done
            
            # Restore previous containers from rollback file
            echo "üì¶ Restoring previous containers..."
            while IFS='=' read -r container image; do
              if [ -n "$container" ] && [ -n "$image" ]; then
                echo "Restoring $container from $image"
                
                # Determine if this was a main service (has main network)
                WAS_MAIN=$(docker inspect "$container" 2>/dev/null | grep "$main_network" | wc -l || echo "0")
                
                RUN_CMD="docker run -d --name \"$container\" --restart unless-stopped --network \"$repo_network\""
                
                if [ "$WAS_MAIN" -gt 0 ]; then
                  RUN_CMD="$RUN_CMD --network \"$main_network\""
                  RUN_CMD="$RUN_CMD -v /home/$ssh_usr/$container/logs/nginx:/var/log/nginx"
                fi
                
                RUN_CMD="$RUN_CMD \"$image\""
                
                echo "Running: $RUN_CMD"
                eval "$RUN_CMD"
              fi
            done < /tmp/rollback.env
            
            echo "‚úÖ Rollback completed successfully."
            sudo systemctl restart nginx