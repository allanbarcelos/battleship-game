name: Build and Deploy Multiple

on:
  push:
    branches:
      - main

jobs:
  discover-dockerfiles:
    runs-on: ubuntu-latest
    outputs:
      dockerfiles: ${{ steps.find-dockerfiles.outputs.dockerfiles }}
      has_root_dockerfile: ${{ steps.find-dockerfiles.outputs.has_root_dockerfile }}
      main_service: ${{ steps.find-dockerfiles.outputs.main_service }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Find all Dockerfiles
        id: find-dockerfiles
        run: |
          # Find all Dockerfiles and their directories
          DOCKERFILES=$(find . -name "Dockerfile" -type f | sed 's|./||' | sed 's|/Dockerfile||' | grep -v "^\.$")
          ROOT_DOCKERFILE=$(find . -maxdepth 1 -name "Dockerfile" -type f)
          
          # Convert to JSON array for output
          DOCKERFILES_JSON=$(echo "$DOCKERFILES" | jq -R -s -c 'split("\n") | map(select(. != ""))')
          echo "dockerfiles=$DOCKERFILES_JSON" >> $GITHUB_OUTPUT
          
          # Check if root Dockerfile exists
          if [ -n "$ROOT_DOCKERFILE" ]; then
            echo "has_root_dockerfile=true" >> $GITHUB_OUTPUT
            echo "main_service=root" >> $GITHUB_OUTPUT
          else
            echo "has_root_dockerfile=false" >> $GITHUB_OUTPUT
            # Determine main service (app or web)
            if echo "$DOCKERFILES" | grep -q "app"; then
              echo "main_service=app" >> $GITHUB_OUTPUT
            elif echo "$DOCKERFILES" | grep -q "web"; then
              echo "main_service=web" >> $GITHUB_OUTPUT
            else
              # Use first service as main if no app/web found
              FIRST_SERVICE=$(echo "$DOCKERFILES" | head -1)
              echo "main_service=$FIRST_SERVICE" >> $GITHUB_OUTPUT
            fi
          fi
          
          # echo "Found Dockerfiles: $DOCKERFILES_JSON"
          # echo "Has root Dockerfile: ${{ steps.find-dockerfiles.outputs.has_root_dockerfile }}"
          # echo "Main service: ${{ steps.find-dockerfiles.outputs.main_service }}"

          echo "Found Dockerfiles: $DOCKERFILES_JSON"
          echo "Has root Dockerfile: $HAS_ROOT"
          echo "Main service: $MAIN_SERVICE"

  set-environment:
    runs-on: ubuntu-latest
    needs: discover-dockerfiles
    outputs:
      repository_name: ${{ steps.set-env.outputs.repository_name }}
      main_network: ${{ steps.set-env.outputs.main_network }}
      repo_network: ${{ steps.set-env.outputs.repo_network }}
      gh_actor: ${{ steps.set-env.outputs.gh_actor }}
      main_service: ${{ needs.discover-dockerfiles.outputs.main_service }}
      has_root_dockerfile: ${{ needs.discover-dockerfiles.outputs.has_root_dockerfile }}
    
    steps:
      - name: Set environment variables
        id: set-env
        run: |
          REPO_NAME=${GITHUB_REPOSITORY##*/}
          echo "repository_name=$REPO_NAME" >> $GITHUB_OUTPUT
          echo "main_network=barcelos.dev" >> $GITHUB_OUTPUT
          echo "repo_network=$REPO_NAME" >> $GITHUB_OUTPUT
          echo "gh_actor=${GITHUB_ACTOR}" >> $GITHUB_OUTPUT

  build-and-push:
    runs-on: ubuntu-latest
    needs: [discover-dockerfiles, set-environment]
    strategy:
      matrix:
        service: ${{ fromJson(needs.discover-dockerfiles.outputs.dockerfiles) }}
    env:
      repository_name: ${{ needs.set-environment.outputs.repository_name }}
      gh_actor: ${{ needs.set-environment.outputs.gh_actor }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ env.gh_actor }}
          password: ${{ secrets.GH_TOKEN }}

      - name: Determine image name
        id: image-name
        run: |
          if [ "${{ matrix.service }}" = "Dockerfile" ]; then
            IMAGE_NAME="ghcr.io/${{ github.repository }}:latest"
            echo "service_name=${{ needs.set-environment.outputs.repository_name }}" >> $GITHUB_OUTPUT
          else
            IMAGE_NAME="ghcr.io/${{ github.repository }}-${{ matrix.service }}:latest"
            echo "service_name=${{ needs.set-environment.outputs.repository_name }}-${{ matrix.service }}" >> $GITHUB_OUTPUT
          fi
          echo "image_name=$IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "Building image: $IMAGE_NAME"

      - name: Build Docker image
        run: |
          if [ "${{ matrix.service }}" = "." ]; then
            docker build -t ${{ steps.image-name.outputs.image_name }} .
          else
            docker build -t ${{ steps.image-name.outputs.image_name }} ./${{ matrix.service }}
          fi

      - name: Push Docker image
        run: docker push ${{ steps.image-name.outputs.image_name }}

      - name: Save image info
        run: |
          echo "SERVICE_${{ matrix.service }}_IMAGE=${{ steps.image-name.outputs.image_name }}" >> $GITHUB_ENV
          echo "SERVICE_${{ matrix.service }}_NAME=${{ steps.image-name.outputs.service_name }}" >> $GITHUB_ENV

  deploy:
    runs-on: ubuntu-latest
    needs: [discover-dockerfiles, set-environment, build-and-push]
    env:
      repository_name: ${{ needs.set-environment.outputs.repository_name }}
      main_network: ${{ needs.set-environment.outputs.main_network }}
      repo_network: ${{ needs.set-environment.outputs.repo_network }}
      gh_actor: ${{ needs.set-environment.outputs.gh_actor }}
      main_service: ${{ needs.set-environment.outputs.main_service }}
      has_root_dockerfile: ${{ needs.set-environment.outputs.has_root_dockerfile }}
    
    steps:
      - name: Setup deployment environment
        id: setup
        run: |
          echo "Preparing deployment for services..."

          DOCKERFILES='${{ needs.discover-dockerfiles.outputs.dockerfiles }}'
          REPO_NAME='${{ needs.set-environment.outputs.repository_name }}'
          HAS_ROOT='${{ needs.set-environment.outputs.has_root_dockerfile }}'
          MAIN_SERVICE='${{ needs.set-environment.outputs.main_service }}'

          # Converter Dockerfiles para array e processar
          SERVICES_JSON=$(echo "$DOCKERFILES" | jq -c --arg repo "$REPO_NAME" --arg has_root "$HAS_ROOT" --arg main_service "$MAIN_SERVICE" '
            map(
              if . == "." then
                {
                  "name": $repo,
                  "dir": ".",
                  "is_main": ($has_root == "true")
                }
              else
                {
                  "name": ($repo + "-" + .),
                  "dir": .,
                  "is_main": (($has_root == "false") and (. == $main_service))
                }
              end
            )
          ')

          echo "services_json=$SERVICES_JSON" >> $GITHUB_OUTPUT
          echo "Services to deploy: $SERVICES_JSON"

      - name: Ensure Docker networks exist
        uses: appleboy/ssh-action@v0.1.9
        with:
          host: ${{ secrets.SSH_HST }}
          username: ${{ secrets.SSH_USR }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PRT }}
          envs: main_network,repo_network
          script: |
            echo "ðŸ” Checking Docker networks..."
            
            # Check main network
            if docker network ls | grep -q "$main_network"; then
              echo "âœ… Network '$main_network' already exists."
            else
              echo "ðŸ“¦ Creating network '$main_network'..."
              docker network create "$main_network"
              echo "âœ… Network '$main_network' created successfully."
            fi
            
            # Check repository network
            if docker network ls | grep -q "$repo_network"; then
              echo "âœ… Network '$repo_network' already exists."
            else
              echo "ðŸ“¦ Creating network '$repo_network'..."
              docker network create "$repo_network"
              echo "âœ… Network '$repo_network' created successfully."
            fi

      - name: Save previous images for rollback
        uses: appleboy/ssh-action@v0.1.9
        with:
          host: ${{ secrets.SSH_HST }}
          username: ${{ secrets.SSH_USR }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PRT }}
          envs: repository_name
          script: |
            echo "Saving previous images for rollback..."
            ROLLBACK_INFO=""
            
            # Get all containers from this repository
            CONTAINERS=$(docker ps -a --filter "name=$repository_name" --format "{{.Names}}")
            
            for container in $CONTAINERS; do
              LAST_IMAGE=$(docker inspect --format='{{.Config.Image}}' "$container" 2>/dev/null || echo "")
              if [ -n "$LAST_IMAGE" ]; then
                ROLLBACK_INFO="${ROLLBACK_INFO}${container}=${LAST_IMAGE}\n"
                echo "Previous image for $container: $LAST_IMAGE"
              fi
            done
            
            echo -e "$ROLLBACK_INFO" > /tmp/rollback.env
            echo "Rollback information saved."

      - name: Deploy all containers
        id: deploy
        uses: appleboy/ssh-action@v0.1.9
        env:
          ssh_usr: ${{ secrets.SSH_USR }}
          services_json: ${{ steps.setup.outputs.services_json }}
          gh_token: ${{ secrets.GH_TOKEN }}
        with:
          host: ${{ secrets.SSH_HST }}
          username: ${{ secrets.SSH_USR }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PRT }}
          envs: gh_token,repository_name,main_network,repo_network,ssh_usr,services_json
          script: |
            echo "ðŸ” Logging in to GitHub Container Registry..."
            echo "$gh_token" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin

            # Parse services JSON corretamente
            echo "Raw services_json: $services_json"
            
            # Verificar se o JSON Ã© vÃ¡lido
            if ! echo "$services_json" | jq empty 2>/dev/null; then
              echo "âŒ ERROR: Invalid JSON format"
              exit 1
            fi

            # Processar cada serviÃ§o
            SERVICE_COUNT=$(echo "$services_json" | jq length)
            echo "Found $SERVICE_COUNT services to deploy"

            # Primeiro, puxar todas as imagens
            echo "ðŸ“¦ Pulling all images..."
            for i in $(seq 0 $(($SERVICE_COUNT - 1))); do
              SERVICE=$(echo "$services_json" | jq -c ".[$i]")
              SERVICE_NAME=$(echo "$SERVICE" | jq -r '.name')
              SERVICE_DIR=$(echo "$SERVICE" | jq -r '.dir')
              IS_MAIN=$(echo "$SERVICE" | jq -r '.is_main')

              echo "Processing service: $SERVICE_NAME (dir: $SERVICE_DIR, main: $IS_MAIN)"

              if [ "$SERVICE_DIR" = "." ]; then
                IMAGE_NAME="ghcr.io/${{ github.repository }}:latest"
              else
                IMAGE_NAME="ghcr.io/${{ github.repository }}-$SERVICE_DIR:latest"
              fi

              echo "Pulling image: $IMAGE_NAME"
              docker pull "$IMAGE_NAME" || echo "âš ï¸ Failed to pull $IMAGE_NAME, continuing..."
            done

            # Parar e remover containers antigos
            echo "ðŸ›‘ Stopping old containers..."
            OLD_CONTAINERS=$(docker ps -a --filter "name=$repository_name" --format "{{.Names}}")
            for container in $OLD_CONTAINERS; do
              echo "Stopping and removing: $container"
              docker stop "$container" 2>/dev/null || true
              docker rm "$container" 2>/dev/null || true
            done

            # Iniciar todos os novos containers
            echo "ðŸš€ Starting all containers..."
            for i in $(seq 0 $(($SERVICE_COUNT - 1))); do
              SERVICE=$(echo "$services_json" | jq -c ".[$i]")
              SERVICE_NAME=$(echo "$SERVICE" | jq -r '.name')
              SERVICE_DIR=$(echo "$SERVICE" | jq -r '.dir')
              IS_MAIN=$(echo "$SERVICE" | jq -r '.is_main')

              if [ "$SERVICE_DIR" = "." ]; then
                IMAGE_NAME="ghcr.io/${{ github.repository }}:latest"
              else
                IMAGE_NAME="ghcr.io/${{ github.repository }}-$SERVICE_DIR:latest"
              fi

              echo "Starting container: $SERVICE_NAME from $IMAGE_NAME"

              # Comando base docker run
              RUN_CMD="docker run -d --name \"$SERVICE_NAME\" --restart unless-stopped"

              # Conectar Ã  rede do repositÃ³rio (sempre)
              RUN_CMD="$RUN_CMD --network \"$repo_network\""

              # Conectar Ã  rede principal se for serviÃ§o principal
              if [ "$IS_MAIN" = "true" ]; then
                RUN_CMD="$RUN_CMD --network \"$main_network\""
                # Mapeamento de volume apenas para serviÃ§o principal
                RUN_CMD="$RUN_CMD -v /home/$ssh_usr/$SERVICE_NAME/logs/nginx:/var/log/nginx"
              fi

              # Adicionar imagem
              RUN_CMD="$RUN_CMD \"$IMAGE_NAME\""

              echo "Running: $RUN_CMD"
              eval "$RUN_CMD" || echo "âŒ Failed to start container $SERVICE_NAME"
            done

            echo "â³ Waiting for containers to start..."
            sleep 10

            # Verificar se todos os containers estÃ£o rodando
            ALL_RUNNING=true
            for i in $(seq 0 $(($SERVICE_COUNT - 1))); do
              SERVICE=$(echo "$services_json" | jq -c ".[$i]")
              SERVICE_NAME=$(echo "$SERVICE" | jq -r '.name')
              
              if docker inspect -f '{{.State.Running}}' "$SERVICE_NAME" 2>/dev/null | grep -q true; then
                echo "âœ… Container $SERVICE_NAME started successfully."
              else
                echo "âŒ Container $SERVICE_NAME failed to start."
                ALL_RUNNING=false
              fi
            done

            if [ "$ALL_RUNNING" = true ]; then
              echo "âœ… All containers started successfully."
              # Reiniciar nginx se serviÃ§o principal existe
              MAIN_SERVICE_EXISTS=$(echo "$services_json" | jq '[.[] | select(.is_main == "true")] | length')
              if [ "$MAIN_SERVICE_EXISTS" -gt 0 ]; then
                sudo systemctl restart nginx
                echo "âœ… Nginx restarted."
              fi
            else
              echo "âŒ Deployment failed â€” some containers did not start."
              exit 1
            fi


      - name: Rollback on failure
        if: failure()
        uses: appleboy/ssh-action@v0.1.9
        env:
          ssh_usr: ${{ secrets.SSH_USR }}
        with:
          host: ${{ secrets.SSH_HST }}
          username: ${{ secrets.SSH_USR }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PRT }}
          envs: repository_name,main_network,repo_network,ssh_usr
          script: |
            echo "ðŸ”„ Starting rollback..."
            
            if [ ! -f /tmp/rollback.env ]; then
              echo "âŒ No rollback file found."
              exit 1
            fi
            
            # Stop and remove current containers
            echo "ðŸ›‘ Stopping current containers..."
            CURRENT_CONTAINERS=$(docker ps -a --filter "name=$repository_name" --format "{{.Names}}")
            for container in $CURRENT_CONTAINERS; do
              docker stop "$container" 2>/dev/null || true
              docker rm "$container" 2>/dev/null || true
            done
            
            # Restore previous containers from rollback file
            echo "ðŸ“¦ Restoring previous containers..."
            while IFS='=' read -r container image; do
              if [ -n "$container" ] && [ -n "$image" ]; then
                echo "Restoring $container from $image"
                
                # Determine if this was a main service (has main network)
                WAS_MAIN=$(docker inspect "$container" 2>/dev/null | grep "$main_network" | wc -l || echo "0")
                
                RUN_CMD="docker run -d --name \"$container\" --restart unless-stopped --network \"$repo_network\""
                
                if [ "$WAS_MAIN" -gt 0 ]; then
                  RUN_CMD="$RUN_CMD --network \"$main_network\""
                  RUN_CMD="$RUN_CMD -v /home/$ssh_usr/$container/logs/nginx:/var/log/nginx"
                fi
                
                RUN_CMD="$RUN_CMD \"$image\""
                
                echo "Running: $RUN_CMD"
                eval "$RUN_CMD"
              fi
            done < /tmp/rollback.env
            
            echo "âœ… Rollback completed successfully."
            sudo systemctl restart nginx