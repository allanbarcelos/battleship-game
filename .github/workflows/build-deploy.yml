name: Build and Deploy Multiple

on:
  push:
    branches:
      - main

jobs:
  discover-dockerfiles:
    runs-on: ubuntu-latest
    outputs:
      dockerfiles: ${{ steps.find-dockerfiles.outputs.dockerfiles }}
      has_root_dockerfile: ${{ steps.find-dockerfiles.outputs.has_root_dockerfile }}
      main_service: ${{ steps.find-dockerfiles.outputs.main_service }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Find all Dockerfiles
        id: find-dockerfiles
        run: |
          # Find all Dockerfiles and their directories
          DOCKERFILES=$(find . -name "Dockerfile" -type f | sed 's|./||' | sed 's|/Dockerfile||' | grep -v "^\.$")
          ROOT_DOCKERFILE=$(find . -maxdepth 1 -name "Dockerfile" -type f)
          
          # Convert to JSON array for output
          DOCKERFILES_JSON=$(echo "$DOCKERFILES" | jq -R -s -c 'split("\n") | map(select(. != ""))')
          echo "dockerfiles=$DOCKERFILES_JSON" >> $GITHUB_OUTPUT
          
          # Check if root Dockerfile exists
          if [ -n "$ROOT_DOCKERFILE" ]; then
            echo "has_root_dockerfile=true" >> $GITHUB_OUTPUT
            echo "main_service=root" >> $GITHUB_OUTPUT
          else
            echo "has_root_dockerfile=false" >> $GITHUB_OUTPUT
            # Determine main service (app or web)
            if echo "$DOCKERFILES" | grep -q "app"; then
              echo "main_service=app" >> $GITHUB_OUTPUT
            elif echo "$DOCKERFILES" | grep -q "web"; then
              echo "main_service=web" >> $GITHUB_OUTPUT
            else
              # Use first service as main if no app/web found
              FIRST_SERVICE=$(echo "$DOCKERFILES" | head -1)
              echo "main_service=$FIRST_SERVICE" >> $GITHUB_OUTPUT
            fi
          fi
          
          echo "Found Dockerfiles: $DOCKERFILES_JSON"
          echo "Has root Dockerfile: ${{ steps.find-dockerfiles.outputs.has_root_dockerfile }}"
          echo "Main service: ${{ steps.find-dockerfiles.outputs.main_service }}"

  set-environment:
    runs-on: ubuntu-latest
    needs: discover-dockerfiles
    outputs:
      repository_name: ${{ steps.set-env.outputs.repository_name }}
      main_network: ${{ steps.set-env.outputs.main_network }}
      repo_network: ${{ steps.set-env.outputs.repo_network }}
      gh_actor: ${{ steps.set-env.outputs.gh_actor }}
      main_service: ${{ needs.discover-dockerfiles.outputs.main_service }}
      has_root_dockerfile: ${{ needs.discover-dockerfiles.outputs.has_root_dockerfile }}
    
    steps:
      - name: Set environment variables
        id: set-env
        run: |
          REPO_NAME=${GITHUB_REPOSITORY##*/}
          echo "repository_name=$REPO_NAME" >> $GITHUB_OUTPUT
          echo "main_network=barcelos.dev" >> $GITHUB_OUTPUT
          echo "repo_network=$REPO_NAME" >> $GITHUB_OUTPUT
          echo "gh_actor=${GITHUB_ACTOR}" >> $GITHUB_OUTPUT

  build-and-push:
    runs-on: ubuntu-latest
    needs: [discover-dockerfiles, set-environment]
    strategy:
      matrix:
        service: ${{ fromJson(needs.discover-dockerfiles.outputs.dockerfiles) }}
    env:
      repository_name: ${{ needs.set-environment.outputs.repository_name }}
      gh_actor: ${{ needs.set-environment.outputs.gh_actor }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ env.gh_actor }}
          password: ${{ secrets.GH_TOKEN }}

      - name: Determine image name
        id: image-name
        run: |
          if [ "${{ matrix.service }}" = "." ]; then
            IMAGE_NAME="ghcr.io/${{ github.repository }}:latest"
            echo "service_name=${{ needs.set-environment.outputs.repository_name }}" >> $GITHUB_OUTPUT
          else
            IMAGE_NAME="ghcr.io/${{ github.repository }}-${{ matrix.service }}:latest"
            echo "service_name=${{ needs.set-environment.outputs.repository_name }}-${{ matrix.service }}" >> $GITHUB_OUTPUT
          fi
          echo "image_name=$IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "Building image: $IMAGE_NAME"

      - name: Build Docker image
        run: |
          if [ "${{ matrix.service }}" = "." ]; then
            docker build -t ${{ steps.image-name.outputs.image_name }} .
          else
            docker build -t ${{ steps.image-name.outputs.image_name }} ./${{ matrix.service }}
          fi

      - name: Push Docker image
        run: docker push ${{ steps.image-name.outputs.image_name }}

      - name: Save image info
        run: |
          echo "SERVICE_${{ matrix.service }}_IMAGE=${{ steps.image-name.outputs.image_name }}" >> $GITHUB_ENV
          echo "SERVICE_${{ matrix.service }}_NAME=${{ steps.image-name.outputs.service_name }}" >> $GITHUB_ENV

  deploy:
    runs-on: ubuntu-latest
    needs: [discover-dockerfiles, set-environment, build-and-push]
    env:
      repository_name: ${{ needs.set-environment.outputs.repository_name }}
      main_network: ${{ needs.set-environment.outputs.main_network }}
      repo_network: ${{ needs.set-environment.outputs.repo_network }}
      gh_actor: ${{ needs.set-environment.outputs.gh_actor }}
      main_service: ${{ needs.set-environment.outputs.main_service }}
      has_root_dockerfile: ${{ needs.set-environment.outputs.has_root_dockerfile }}
    
    steps:
      - name: Setup deployment environment
        id: setup
        run: |
          echo "Preparing deployment for services..."

          DOCKERFILES=${{ needs.discover-dockerfiles.outputs.dockerfiles }}
          REPO_NAME=${{ needs.set-environment.outputs.repository_name }}
          HAS_ROOT=${{ needs.set-environment.outputs.has_root_dockerfile }}
          MAIN_SERVICE=${{ needs.set-environment.outputs.main_service }}

          # Mapear array JSON para objeto com nomes e flags
          SERVICES_JSON=$(echo "$DOCKERFILES" | jq -c --arg repo "$REPO_NAME" --arg has_root "$HAS_ROOT" --arg main_service "$MAIN_SERVICE" '
            map(
              if . == "." then
                {
                  "name": $repo,
                  "dir": ".",
                  "is_main": ($has_root == "true")
                }
              else
                {
                  "name": ($repo + "-" + .),
                  "dir": .,
                  "is_main": (($has_root == "false") and (. == $main_service))
                }
              end
            )
          ')

          echo "services_json=$SERVICES_JSON" >> $GITHUB_OUTPUT
          echo "Services to deploy: $SERVICES_JSON"

      - name: Ensure Docker networks exist
        uses: appleboy/ssh-action@v0.1.9
        with:
          host: ${{ secrets.SSH_HST }}
          username: ${{ secrets.SSH_USR }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PRT }}
          envs: main_network,repo_network
          script: |
            echo "üîç Checking Docker networks..."
            
            # Check main network
            if docker network ls | grep -q "$main_network"; then
              echo "‚úÖ Network '$main_network' already exists."
            else
              echo "üì¶ Creating network '$main_network'..."
              docker network create "$main_network"
              echo "‚úÖ Network '$main_network' created successfully."
            fi
            
            # Check repository network
            if docker network ls | grep -q "$repo_network"; then
              echo "‚úÖ Network '$repo_network' already exists."
            else
              echo "üì¶ Creating network '$repo_network'..."
              docker network create "$repo_network"
              echo "‚úÖ Network '$repo_network' created successfully."
            fi


      - name: Clean up old container structure
        uses: appleboy/ssh-action@v0.1.9
        with:
          host: ${{ secrets.SSH_HST }}
          username: ${{ secrets.SSH_USR }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PRT }}
          envs: repository_name
          script: |
            echo "üßπ Cleaning up old container structure..."
            
            # Find and remove old containers (using old naming pattern)
            OLD_CONTAINERS=$(docker ps -a --filter "name=$repository_name" --format "{{.Names}}" | grep -E "^$repository_name(-[a-zA-Z0-9_-]+)?$")
            
            if [ -n "$OLD_CONTAINERS" ]; then
              echo "Found old containers to remove:"
              echo "$OLD_CONTAINERS"
              
              for container in $OLD_CONTAINERS; do
                echo "Stopping and removing container: $container"
                docker stop "$container" 2>/dev/null || true
                docker rm "$container" 2>/dev/null || true
                echo "‚úÖ Container $container removed"
              done
            else
              echo "No old containers found with pattern: $repository_name"
            fi
            
            # Clean up old images (dangling and unused)
            echo "Cleaning up old images..."
            OLD_IMAGES=$(docker images --filter "dangling=true" -q)
            if [ -n "$OLD_IMAGES" ]; then
              echo "Removing dangling images..."
              docker rmi $OLD_IMAGES 2>/dev/null || true
            fi
            
            # Remove unused images (more aggressive cleanup)
            echo "Removing unused images..."
            docker image prune -a -f 2>/dev/null || true
            
            echo "‚úÖ Old container structure cleanup completed"


      - name: Save previous images for rollback
        uses: appleboy/ssh-action@v0.1.9
        with:
          host: ${{ secrets.SSH_HST }}
          username: ${{ secrets.SSH_USR }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PRT }}
          envs: repository_name
          script: |
            echo "Saving previous images for rollback..."
            ROLLBACK_INFO=""
            
            # Get all containers from this repository
            CONTAINERS=$(docker ps -a --filter "name=$repository_name" --format "{{.Names}}")
            
            for container in $CONTAINERS; do
              LAST_IMAGE=$(docker inspect --format='{{.Config.Image}}' "$container" 2>/dev/null || echo "")
              if [ -n "$LAST_IMAGE" ]; then
                ROLLBACK_INFO="${ROLLBACK_INFO}${container}=${LAST_IMAGE}\n"
                echo "Previous image for $container: $LAST_IMAGE"
              fi
            done
            
            echo -e "$ROLLBACK_INFO" > /tmp/rollback.env
            echo "Rollback information saved."

      - name: Deploy all containers
        id: deploy
        uses: appleboy/ssh-action@v0.1.9
        env:
          ssh_usr: ${{ secrets.SSH_USR }}
          services_json: ${{ steps.setup.outputs.services_json }}
          gh_token: ${{ secrets.GH_TOKEN }}
        with:
          host: ${{ secrets.SSH_HST }}
          username: ${{ secrets.SSH_USR }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PRT }}
          envs: gh_token,repository_name,main_network,repo_network,ssh_usr,services_json
          script: |
            echo "üîê Logging in to GitHub Container Registry..."
            echo "$gh_token" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin

            # Parse services JSON
            SERVICES=$(echo "$services_json" | jq -c '.[]')

            # First, pull all images
            echo "üì¶ Pulling all images..."
            while IFS= read -r service; do
              SERVICE_NAME=$(echo "$service" | jq -r '.name')
              SERVICE_DIR=$(echo "$service" | jq -r '.dir')
              IS_MAIN=$(echo "$service" | jq -r '.is_main')

              # Fallbacks para evitar valores vazios
              if [ -z "$SERVICE_NAME" ]; then
                echo "‚ùå ERROR: Service name is empty, skipping..."
                continue
              fi

              if [ "$SERVICE_DIR" = "." ] || [ -z "$SERVICE_DIR" ]; then
                IMAGE_NAME="ghcr.io/${{ github.repository }}:latest"
              else
                IMAGE_NAME="ghcr.io/${{ github.repository }}-$SERVICE_DIR:latest"
              fi

              echo "Pulling image: $IMAGE_NAME"
              docker pull "$IMAGE_NAME" || echo "‚ö†Ô∏è Failed to pull $IMAGE_NAME, continuing..."
            done <<< "$SERVICES"

            # Stop and remove old containers
            echo "üõë Stopping old containers..."
            OLD_CONTAINERS=$(docker ps -a --filter "name=$repository_name" --format "{{.Names}}")
            for container in $OLD_CONTAINERS; do
              echo "Stopping and removing: $container"
              docker stop "$container" 2>/dev/null || true
              docker rm "$container" 2>/dev/null || true
            done

            # Start all new containers
            echo "üöÄ Starting all containers..."
            while IFS= read -r service; do
              SERVICE_NAME=$(echo "$service" | jq -r '.name')
              SERVICE_DIR=$(echo "$service" | jq -r '.dir')
              IS_MAIN=$(echo "$service" | jq -r '.is_main')

              # Skip if service name is empty
              if [ -z "$SERVICE_NAME" ]; then
                echo "‚ùå ERROR: Service name is empty, skipping..."
                continue
              fi

              if [ "$SERVICE_DIR" = "." ] || [ -z "$SERVICE_DIR" ]; then
                IMAGE_NAME="ghcr.io/${{ github.repository }}:latest"
              else
                IMAGE_NAME="ghcr.io/${{ github.repository }}-$SERVICE_DIR:latest"
              fi

              echo "Starting container: $SERVICE_NAME from $IMAGE_NAME"

              # Base docker run command
              RUN_CMD="docker run -d --name \"$SERVICE_NAME\" --restart unless-stopped"

              # Attach to repository network (always)
              if [ -n "$repo_network" ]; then
                RUN_CMD="$RUN_CMD --network \"$repo_network\""
              else
                echo "‚ö†Ô∏è repo_network is empty, skipping network assignment"
              fi

              # Attach to main network if this is main service
              if [ "$IS_MAIN" = "true" ] && [ -n "$main_network" ]; then
                RUN_CMD="$RUN_CMD --network \"$main_network\""
                # Volume mapping only for main service
                RUN_CMD="$RUN_CMD -v /home/$ssh_usr/$SERVICE_NAME/logs/nginx:/var/log/nginx"
              fi

              # Add image
              RUN_CMD="$RUN_CMD \"$IMAGE_NAME\""

              echo "Running: $RUN_CMD"
              eval "$RUN_CMD"
            done <<< "$SERVICES"

            echo "‚è≥ Waiting for containers to start..."
            sleep 10

            # Verify all containers are running
            ALL_RUNNING=true
            while IFS= read -r service; do
              SERVICE_NAME=$(echo "$service" | jq -r '.name')
              if [ -z "$SERVICE_NAME" ]; then
                continue
              fi

              if docker inspect -f '{{.State.Running}}' "$SERVICE_NAME" 2>/dev/null | grep -q true; then
                echo "‚úÖ Container $SERVICE_NAME started successfully."
              else
                echo "‚ùå Container $SERVICE_NAME failed to start."
                ALL_RUNNING=false
              fi
            done <<< "$SERVICES"

            if [ "$ALL_RUNNING" = true ]; then
              echo "‚úÖ All containers started successfully."
              # Restart nginx if main service exists
              MAIN_SERVICE_EXISTS=$(echo "$services_json" | jq 'map(select(.is_main == "true")) | length')
              if [ "$MAIN_SERVICE_EXISTS" -gt 0 ]; then
                sudo systemctl restart nginx
                echo "‚úÖ Nginx restarted."
              fi
            else
              echo "‚ùå Deployment failed ‚Äî initiating rollback."
              exit 1
            fi


      - name: Rollback on failure
        if: failure()
        uses: appleboy/ssh-action@v0.1.9
        env:
          ssh_usr: ${{ secrets.SSH_USR }}
        with:
          host: ${{ secrets.SSH_HST }}
          username: ${{ secrets.SSH_USR }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PRT }}
          envs: repository_name,main_network,repo_network,ssh_usr
          script: |
            echo "üîÑ Starting rollback..."
            
            if [ ! -f /tmp/rollback.env ]; then
              echo "‚ùå No rollback file found."
              exit 1
            fi
            
            # Stop and remove current containers
            echo "üõë Stopping current containers..."
            CURRENT_CONTAINERS=$(docker ps -a --filter "name=$repository_name" --format "{{.Names}}")
            for container in $CURRENT_CONTAINERS; do
              docker stop "$container" 2>/dev/null || true
              docker rm "$container" 2>/dev/null || true
            done
            
            # Restore previous containers from rollback file
            echo "üì¶ Restoring previous containers..."
            while IFS='=' read -r container image; do
              if [ -n "$container" ] && [ -n "$image" ]; then
                echo "Restoring $container from $image"
                
                # Determine if this was a main service (has main network)
                WAS_MAIN=$(docker inspect "$container" 2>/dev/null | grep "$main_network" | wc -l || echo "0")
                
                RUN_CMD="docker run -d --name \"$container\" --restart unless-stopped --network \"$repo_network\""
                
                if [ "$WAS_MAIN" -gt 0 ]; then
                  RUN_CMD="$RUN_CMD --network \"$main_network\""
                  RUN_CMD="$RUN_CMD -v /home/$ssh_usr/$container/logs/nginx:/var/log/nginx"
                fi
                
                RUN_CMD="$RUN_CMD \"$image\""
                
                echo "Running: $RUN_CMD"
                eval "$RUN_CMD"
              fi
            done < /tmp/rollback.env
            
            echo "‚úÖ Rollback completed successfully."
            sudo systemctl restart nginx